import textwrap


def data(name, size, value, idx=0):
    print 'DATA {name}+0x{idx:02x}(SB)/{size}, $({value})'.format(
            name=name, idx=idx, size=size, value=value)


def docstring(text):
    lines = textwrap.wrap(text, width=78, initial_indent='// ', subsequent_indent='// ')
    print '\n'.join(lines)


def declare(name, length, doc):
    print
    assert doc.startswith(name)
    assert doc[-1] == '.'
    docstring(doc)
    print 'GLOBL {name}(SB), (RODATA+NOPTR), ${length}'.format(
            name=name, length=length)


def output_float(name, doc, value):
    """
    Output golang assembly DATA section for the given float value.
    """
    declare(name=name, length=8, doc=doc)
    data(name=name, size=8, value=value)


def output_byte_array(name, doc, array):
    """
    Output golang assembly DATA section for the given byte array.
    """
    declare(name=name, length=len(array), doc=doc)
    for i, b in enumerate(array):
        data(name=name, idx=i, size=1, value=b)


# Generated header.
print '// Generated by {filename}. DO NOT EDIT.'.format(
        filename=__file__,
        )

# Byte shuffle value for the byte stage of the interleaving.
shuf128 = [
    0, 128, 1, 128,  2, 128,  3, 128,
    8, 128, 9, 128, 10, 128, 11, 128,
]
output_byte_array(
        'spreadbytes',
        'spreadbytes is the VPSHUFB input required to spread bytes in each word.',
        shuf128 * 2,
        )

# "Lookup table" to perform spread operation on nibbles.
def spread(x):
    s = 0
    i = 0
    while x:
        s |= (x&1)<<i
        x >>= 1
        i += 2
    return s


output_byte_array(
        'spreadnibbleslut',
        'spreadnibbleslut is a lookup table to perform 4-bit spread operations with VPSHUFB.',
        list(map(spread, range(16))) * 2,
)

# Nibble masks.
output_byte_array(
        'lonibblemask',
        'lonibblemask selects the low nibble of each byte in a 64-bit word.',
        [0x0f]*8,
        )
output_byte_array(
        'hinibblemask',
        'hinibblemask selects the high nibble of each byte in a 64-bit word.',
        [0xf0]*8,
        )

# Floating point constants.
output_float(
        'reciprocal180',
        'reciprocal180 is the float 1/180.0 for quantization.',
        1/180.0,
)
output_float(
        'reciprocal360',
        'reciprocal360 is the float 1/360.0 for quantization.',
        1/360.0,
)
output_float(
        'onepointfive',
        'onepointfive is the float value 1.5 needed for quantization.',
        1.5,
        )

